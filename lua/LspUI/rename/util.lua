local lsp, api = vim.lsp, vim.api
local rename_feature = lsp.protocol.Methods.textDocument_rename
local prepare_rename_feature = lsp.protocol.Methods.textDocument_prepareRename

local config = require("LspUI.config")
local windows = require("LspUI.lib.windows")
local lib_util = require("LspUI.lib.util")

local M = {}

-- get all valid clients of rename
--- @param buffer_id integer
--- @return table|nil clients array or nil
M.get_clients = function(buffer_id)
	-- note: we need get lsp clients attached to current buffer
	local clients = lsp.get_clients({ bufnr = buffer_id, method = rename_feature })
	return #clients == 0 and nil or clients
end

-- rename
--- @param client table lsp client instance, must be element of func `get_clients`
--- @param buffer integer buffer id
--- @param position_param table this param must be generated by `vim.lsp.util.make_position_params`, has newname attribute
--- @param callback function
M.rename = function(client, buffer, position_param, callback)
	local handler = client.handlers[rename_feature] or lsp.handlers[rename_feature]
	client.request(rename_feature, position_param, function(...)
		handler(...)
		callback()
	end, buffer)
end

-- prepare rename, whether we can execute rename
-- if request return eroor, that mean we can't rename, and we should skip this
--- @param client table lsp client instance, must be element of func `get_clients`
--- @param position_param table this param must be generated by `vim.lsp.util.make_position_params`
--- @param callback function
M.prepare_rename = function(client, position_param, callback)
	client.request(prepare_rename_feature, position_param, function(err, result)
		if err or result == nil then
			callback(false)
			return
		end
		callback(true)
	end)
end

-- do rename, a wrap function for prepare_rename and rename
--- @param id integer
--- @param clients table lsp client instance, must be element of func `get_clients`
--- @param buffer integer buffer id
--- @param position_param table this param must be generated by `vim.lsp.util.make_position_params`, has newname attribute
M.do_rename = function(id, clients, buffer, position_param)
	local client = clients[id]
	-- when client is nil, return
	if not client then
		return
	end
	-- TODO: client.supports_method is not listed by document
	if client.supports_method(prepare_rename_feature) then
		M.prepare_rename(
			client,
			position_param,
			-- result is true, that is preparename is ok
			--- @param result boolean
			function(result)
				if result then
					M.rename(client, buffer, position_param, function()
						local next_id, _ = next(clients, id)
						M.do_rename(next_id, clients, buffer, position_param)
					end)
				else
					local next_id, _ = next(clients, id)
					M.do_rename(next_id, clients, buffer, position_param)
				end
			end
		)
	else
		M.rename(client, buffer, position_param, function()
			local next_id, _ = next(clients, id)
			M.do_rename(next_id, clients, buffer, position_param)
		end)
	end
end

-- wrap windows.close_window
-- add detect insert mode
--- @param window_id integer
local close_window = function(window_id)
	if vim.fn.mode() == "i" then
		vim.cmd([[stopinsert]])
	end
	windows.close_window(window_id)
end

-- keybinding and autocommand
--- @param window_id integer rename float window's id
--- @param old_name string the word's old name
--- @param clients table lsp clients
--- @param old_buffer integer the buffer which word belongs to
--- @param new_buffer integer the buffer which attach wto rename float window
--- @param position_param table this param must be generated by `vim.lsp.util.make_position_params`
M.keybinding_autocmd = function(window_id, old_name, clients, old_buffer, new_buffer, position_param)
	-- keybinding exec
	vim.keymap.set({ "n", "v", "i" }, config.options.rename.key_binding.exec, function()
		local new_name = vim.trim(api.nvim_get_current_line())
		if old_name ~= new_name then
			position_param.newName = new_name
			M.do_rename(1, clients, old_buffer, position_param)
		end
		close_window(window_id)
	end)

	-- keybinding quit
	vim.keymap.set({ "n" }, config.options.rename.key_binding.quit, function()
		close_window(window_id)
	end, { buffer = new_buffer })

	-- auto command: auto close window, when focus leave rename float window
	api.nvim_create_autocmd("WinLeave", {
		buffer = new_buffer,
		once = true,
		callback = function()
			close_window(window_id)
		end,
		desc = lib_util.command_desc("Rename auto close windows when focus leave"),
	})
end

return M
